import React, { useState, useRef, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Send, Loader2, Zap } from "lucide-react";
import { useIsMobile } from "@/hooks/use-mobile";
import ReactMarkdown from 'react-markdown';
import rehypeRaw from 'rehype-raw';
import { cn } from "@/lib/utils";
import { useAuth } from "@/context/AuthContext";
import { Message } from "@/components/types";
import { supabase } from "@/lib/supabase";

interface MysteryChatProps {
  initialTheme?: string;
  initialPlayerCount?: number;
  initialHasAccomplice?: boolean;
  initialScriptType?: 'full' | 'pointForm';
  initialAdditionalDetails?: string;
  savedMysteryId?: string;
  onSave: (message: Message) => Promise<void>;
  onGenerateFinal?: (messages: Message[]) => Promise<void>;
  initialMessages?: Message[];
  isLoadingHistory?: boolean;
  systemInstruction?: string;
  preventDuplicateMessages?: boolean;
  skipForm?: boolean;
  needsInitialAIResponse?: boolean;
  usePageScroll?: boolean;
}

export default function MysteryChat({
  initialTheme,
  initialPlayerCount,
  initialHasAccomplice,
  initialScriptType,
  initialAdditionalDetails,
  savedMysteryId,
  onSave,
  onGenerateFinal,
  initialMessages = [],
  isLoadingHistory = false,
  systemInstruction,
  preventDuplicateMessages = false,
  skipForm = false,
  needsInitialAIResponse = false,
  usePageScroll = false
}: MysteryChatProps) {
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isAiTyping, setIsAiTyping] = useState(false);
  const [currentTheme, setCurrentTheme] = useState(initialTheme || '');
  const [currentPlayerCount, setCurrentPlayerCount] = useState<number | null>(initialPlayerCount || null);
  const [currentHasAccomplice, setCurrentHasAccomplice] = useState(initialHasAccomplice || false);
  const [currentScriptType, setCurrentScriptType] = useState(initialScriptType || 'full');
  const [currentAdditionalDetails, setCurrentAdditionalDetails] = useState(initialAdditionalDetails || '');
  const [hasTriggeredInitialResponse, setHasTriggeredInitialResponse] = useState(false);
  const { isAuthenticated } = useAuth();
  const isMobile = useIsMobile();
  const bottomRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // Helper function to ensure proper timestamp handling
  const ensureValidTimestamp = (message: any): Message => {
    let timestamp: Date;
    
    if (message.timestamp) {
      timestamp = message.timestamp instanceof Date ? message.timestamp : new Date(message.timestamp);
    } else if (message.created_at) {
      timestamp = new Date(message.created_at);
    } else {
      timestamp = new Date();
    }

    return {
      id: message.id || Date.now().toString(),
      content: message.content || '',
      is_ai: message.is_ai !== undefined ? message.is_ai : (message.role === 'assistant'),
      timestamp: timestamp,
      isAutoGenerated: message.isAutoGenerated || false
    };
  };

  useEffect(() => {
    const processedMessages = initialMessages.map(ensureValidTimestamp);
    setMessages(processedMessages);
  }, [initialMessages]);

  // Enhanced effect to handle initial AI response
  useEffect(() => {
    if (needsInitialAIResponse && !hasTriggeredInitialResponse && messages.length > 0 && !isLoadingHistory) {
      console.log("Triggering initial AI response for new conversation");
      setHasTriggeredInitialResponse(true);
      
      // Start AI typing immediately
      setIsAiTyping(true);
      
      // Find the last user message to respond to
      const lastUserMessage = messages.filter(msg => !msg.is_ai).pop();
      if (lastUserMessage) {
        triggerAIResponse(lastUserMessage.content);
      }
    }
  }, [needsInitialAIResponse, hasTriggeredInitialResponse, messages, isLoadingHistory]);

  // Scroll to bottom when messages change or AI is typing
  useEffect(() => {
    if (!usePageScroll) {
      bottomRef.current?.scrollIntoView({ behavior: "smooth" });
    } else {
      // For page-level scrolling, scroll to bottom of page
      window.scrollTo({
        top: document.body.scrollHeight,
        behavior: 'smooth'
      });
    }
  }, [messages, isAiTyping, usePageScroll]);

  useEffect(() => {
    if (initialTheme) {
      setCurrentTheme(initialTheme);
    }
    if (initialPlayerCount) {
      setCurrentPlayerCount(initialPlayerCount);
    }
    if (initialHasAccomplice) {
      setCurrentHasAccomplice(initialHasAccomplice);
    }
    if (initialScriptType) {
      setCurrentScriptType(initialScriptType);
    }
    if (initialAdditionalDetails) {
      setCurrentAdditionalDetails(initialAdditionalDetails);
    }
  }, [initialTheme, initialPlayerCount, initialHasAccomplice, initialScriptType, initialAdditionalDetails]);

  // FIXED: Enhanced function to properly detect if we have player count info
  const hasPlayerCountInfo = () => {
    // Don't consider initialPlayerCount as "having info" unless it's explicitly set and not a default
    if (initialPlayerCount && initialPlayerCount >= 4 && initialPlayerCount <= 32 && currentPlayerCount && currentPlayerCount >= 4 && currentPlayerCount <= 32) {
      console.log("Has explicit valid player count from props:", initialPlayerCount);
      return true;
    }
    
    // Check if any message explicitly mentions valid player count
    const hasPlayerCountInMessages = messages.some(msg => {
      const content = msg.content.toLowerCase();
      // Look for explicit player count mentions with numbers in valid range
      const playerCountMatch = content.match(/(\d+)\s*(player|people|guest|character|participant)/i);
      if (playerCountMatch) {
        const count = parseInt(playerCountMatch[1]);
        if (count >= 4 && count <= 32) {
          console.log("Found valid player count in message:", content.substring(0, 100));
          return true;
        }
      }
      return false;
    });
    
    console.log("Has player count in messages:", hasPlayerCountInMessages);
    return hasPlayerCountInMessages;
  };

  // Helper function to detect if we have theme information
  const hasThemeInfo = () => {
    const hasTheme = currentTheme && currentTheme.trim() !== '' && currentTheme !== 'Murder Mystery';
    console.log("Has theme info:", hasTheme, "Theme:", currentTheme);
    return hasTheme;
  };

  // FIXED: More accurate detection of new conversations that need player count question
  const isNewConversation = () => {
    const playerCountInfo = hasPlayerCountInfo();
    const isNew = messages.length <= 1 && !playerCountInfo;
    console.log("Is new conversation check:", {
      messageCount: messages.length,
      hasPlayerCount: playerCountInfo,
      isNew: isNew
    });
    return isNew;
  };

  const createSystemMessage = (data: any) => {
    // Use provided system instruction if available
    if (systemInstruction) {
      return systemInstruction;
    }

    let systemMsg = "You are a helpful mystery writer. Your job is to help the user create an exciting murder mystery game.";
    
    if (currentTheme) {
      systemMsg += `\nThe user wants to create a murder mystery with theme: ${currentTheme}. `;
    }
    
    if (currentPlayerCount) {
      systemMsg += `The user wants to create a murder mystery with ${currentPlayerCount} players. `;
    }
    
    systemMsg += `The user wants to create a murder mystery with a ${currentScriptType} script. `;
    
    if (currentAdditionalDetails) {
      systemMsg += `\nAdditional details: ${currentAdditionalDetails}. `;
    }
    
    return systemMsg;
  };

  // Enhanced AI response function with retry logic
  const callAIWithRetry = async (messages: any[], systemPrompt: string | null, retryCount = 0): Promise<any> => {
    const maxRetries = 3;
    
    try {
      console.log(`Attempt ${retryCount + 1} - Calling mystery-ai function`);
      
      const requestBody: any = {
        messages: messages,
        promptVersion: 'free',
        preventTruncation: true
      };

      // Only add system prompt if we have one
      if (systemPrompt) {
        requestBody.system = systemPrompt;
      }

      const { data, error } = await supabase.functions.invoke('mystery-ai', {
        body: requestBody
      });

      if (error) {
        throw new Error(`Supabase function error: ${error.message}`);
      }

      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        return data.choices[0].message.content;
      } else if (data && data.error) {
        throw new Error(`API error: ${data.error}`);
      } else {
        throw new Error('Invalid response format from AI service');
      }
    } catch (error) {
      console.error(`Attempt ${retryCount + 1} failed:`, error);
      
      if (retryCount < maxRetries) {
        console.log(`Retrying in ${(retryCount + 1) * 1000}ms...`);
        await new Promise(resolve => setTimeout(resolve, (retryCount + 1) * 1000));
        return callAIWithRetry(messages, systemPrompt, retryCount + 1);
      } else {
        throw error;
      }
    }
  };

  const triggerAIResponse = async (userContent: string) => {
    try {
      console.log("=== Starting AI Request for Initial Response ===");
      
      const systemPrompt = createSystemMessage({
        theme: currentTheme,
        playerCount: currentPlayerCount,
        hasAccomplice: currentHasAccomplice,
        scriptType: currentScriptType,
        additionalDetails: currentAdditionalDetails
      });

      const messagesToSend = messages.map(msg => ({
        role: msg.is_ai ? "assistant" : "user",
        content: msg.content
      }));

      const aiResponse = await callAIWithRetry(messagesToSend, systemPrompt);
      console.log("AI response content:", aiResponse);

      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: aiResponse,
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      const updatedMessages = [...messages, aiMessage];
      setMessages(updatedMessages);

      try {
        await onSave(aiMessage);
      } catch (error) {
        console.error("Error saving AI message:", error);
      }
    } catch (error) {
      console.error('Error calling AI service:', error);
      toast.error("Failed to get AI response. Please try again.");
      
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: "I apologize, but I'm having trouble responding right now. Please try again in a moment.",
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      setMessages([...messages, errorMessage]);
      
      try {
        await onSave(errorMessage);
      } catch (saveError) {
        console.error("Error saving AI error message:", saveError);
      }
    } finally {
      setIsAiTyping(false);
    }
  };

  const handleSendMessage = async (content: string) => {
    if (!content.trim()) return;

    setInput('');

    const userMessage: Message = {
      id: Date.now().toString(),
      content: content.trim(),
      is_ai: false,
      timestamp: new Date(),
      isAutoGenerated: false
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);

    try {
      await onSave(userMessage);
    } catch (error) {
      console.error("Error saving user message:", error);
    }

    setIsAiTyping(true);

    try {
      const systemPrompt = createSystemMessage({
        theme: currentTheme,
        playerCount: currentPlayerCount,
        hasAccomplice: currentHasAccomplice,
        scriptType: currentScriptType,
        additionalDetails: currentAdditionalDetails
      });

      const messagesToSend = newMessages.map(msg => ({
        role: msg.is_ai ? "assistant" : "user",
        content: msg.content
      }));

      const aiResponse = await callAIWithRetry(messagesToSend, systemPrompt);

      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: aiResponse,
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      const updatedMessages = [...newMessages, aiMessage];
      setMessages(updatedMessages);

      try {
        await onSave(aiMessage);
      } catch (error) {
        console.error("Error saving AI message:", error);
      }
    } catch (error) {
      console.error('Error calling AI service:', error);
      toast.error("Failed to get AI response. Please try again.");
      
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: "I apologize, but I'm having trouble responding right now. Please try again in a moment.",
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      setMessages([...newMessages, errorMessage]);
      
      try {
        await onSave(errorMessage);
      } catch (saveError) {
        console.error("Error saving AI error message:", saveError);
      }
    } finally {
      setIsAiTyping(false);
    }
  };

  // Auto-resize textarea
  const handleTextareaChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInput(e.target.value);
    
    // Auto-resize
    if (inputRef.current) {
      inputRef.current.style.height = 'auto';
      inputRef.current.style.height = `${Math.min(inputRef.current.scrollHeight, 150)}px`;
    }
  };

  // Check if AI has provided at least one response
  const hasAIResponse = messages.some(msg => msg.is_ai);

  return (
    <div className={cn(
      "flex flex-col bg-[#F7F3E9]",
      usePageScroll ? "h-full" : "h-full space-y-4 sm:space-y-6"
    )}>
      {/* Chat Messages Area */}
      <div className={cn(
        "space-y-4 sm:space-y-6 bg-[#F7F3E9]",
        usePageScroll ? "pb-32" : "overflow-y-auto h-80 p-3 sm:h-96 sm:p-4"
      )}>
        {/* Loading History */}
        {isLoadingHistory && (
          <div className="text-center text-muted-foreground py-4">
            <Loader2 className="h-5 w-5 sm:h-6 sm:w-6 animate-spin mx-auto mb-2" />
            <p className="text-sm sm:text-base">Loading previous messages...</p>
          </div>
        )}
        
        {messages.map((message) => (
          <div
            key={message.id}
            className={cn(
              "flex",
              message.is_ai ? "justify-start" : "justify-end"
            )}
          >
            <div
              className={cn(
                "rounded-2xl px-4 py-3 sm:px-5 sm:py-4 max-w-[85%] sm:max-w-[80%] shadow-lg",
                message.is_ai
                  ? "bg-[#FEFCF8] text-[#2A2A2A] border-none"
                  : "bg-[#8B1538] text-white border-none"
              )}
            >
              {message.is_ai ? (
                <div className={cn(
                  "prose prose-sm dark:prose-invert max-w-none",
                  isMobile && "text-sm leading-relaxed"
                )}>
                  <ReactMarkdown 
                    rehypePlugins={[rehypeRaw]}
                    components={{
                      h1: ({node, ...props}) => <h1 className={cn(
                        "font-bold mt-3 mb-2 text-[#8B1538]",
                        isMobile ? "text-lg" : "text-2xl"
                      )} {...props} />,
                      h2: ({node, ...props}) => <h2 className={cn(
                        "font-semibold mt-2 mb-1 text-[#8B1538]",
                        isMobile ? "text-base" : "text-xl"
                      )} {...props} />,
                      h3: ({node, ...props}) => <h3 className={cn(
                        "font-medium mt-2 mb-1 text-[#8B1538]",
                        isMobile ? "text-sm" : "text-lg"
                      )} {...props} />,
                      p: ({node, ...props}) => <p className="my-1 leading-relaxed text-[#2A2A2A]" {...props} />,
                      ul: ({node, ...props}) => <ul className={cn(
                        "list-disc my-2",
                        isMobile ? "pl-4" : "pl-6"
                      )} {...props} />,
                      ol: ({node, ...props}) => <ol className={cn(
                        "list-decimal my-2",
                        isMobile ? "pl-4" : "pl-6"
                      )} {...props} />,
                      li: ({node, ...props}) => <li className="my-1 text-[#2A2A2A]" {...props} />,
                      strong: ({node, ...props}) => <strong className="font-bold text-[#8B1538]" {...props} />,
                      em: ({node, ...props}) => <em className="italic" {...props} />,
                      blockquote: ({node, ...props}) => <blockquote className="pl-3 border-l-3 border-[#8B1538] bg-[#F7F3E9] italic my-2 rounded-r-md p-2" {...props} />
                    }}
                  >
                    {message.content}
                  </ReactMarkdown>
                </div>
              ) : (
                <p className={cn(
                  "whitespace-pre-line leading-relaxed",
                  isMobile ? "text-sm" : "text-sm"
                )}>{message.content}</p>
              )}
            </div>
          </div>
        ))}
        
        {/* AI Typing Indicator - Mobile Optimized */}
        {isAiTyping && (
          <div className="flex justify-start">
            <div className="bg-[#FEFCF8] rounded-2xl px-4 py-3 sm:px-5 sm:py-4 max-w-[85%] sm:max-w-[80%] shadow-sm">
              <div className="flex space-x-1">
                <div className="h-2 w-2 bg-[#8B1538]/60 rounded-full animate-bounce" style={{ animationDelay: "0ms" }}></div>
                <div className="h-2 w-2 bg-[#8B1538]/60 rounded-full animate-bounce" style={{ animationDelay: "150ms" }}></div>
                <div className="h-2 w-2 bg-[#8B1538]/60 rounded-full animate-bounce" style={{ animationDelay: "300ms" }}></div>
              </div>
            </div>
          </div>
        )}
        <div ref={bottomRef} />
      </div>

      {/* Fixed Bottom Input and Generate Button */}
      <div className={cn(
      "fixed bottom-0 left-0 right-0 z-20 bg-[#F7F3E9] border-t border-[#F7F3E9]",
      isMobile ? "px-3 py-2" : "px-4 py-3"
      )}>
        <div className={cn(
          "mx-auto space-y-3",
          isMobile ? "max-w-full" : "max-w-4xl"
        )}>
          {/* Text Input */}
          <div className="flex items-end space-x-2 sm:space-x-3 rounded-xl bg-white shadow-sm p-1">
            <div className="flex-grow">
              <Textarea
                ref={inputRef}
                placeholder="Share your ideas for the mystery..."
                value={input}
                onChange={handleTextareaChange}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage(input);
                  }
                }}
                disabled={isAiTyping}
                className={cn(
                  "resize-none border-0 shadow-none focus-visible:ring-0 min-h-[44px] bg-transparent",
                  isMobile ? "text-base" : "text-sm"
                )}
                rows={1}
              />
            </div>
            <Button 
              type="submit" 
              onClick={() => handleSendMessage(input)} 
              disabled={isAiTyping || !input.trim()}
              size={isMobile ? "default" : "icon"}
              className={cn(
                "shrink-0 bg-[#8B1538] hover:bg-[#6B0F28] text-white rounded-lg",
                isMobile ? "h-11 w-11" : "h-9 w-9"
              )}
            >
              {isAiTyping ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <Send className="h-4 w-4" />
              )}
            </Button>
          </div>
          
          {/* Generate Full Mystery Button */}
          {onGenerateFinal && (
            <Button
              onClick={() => onGenerateFinal(messages)}
              disabled={!hasAIResponse}
              size={isMobile ? "default" : "lg"}
              className={cn(
                "w-full bg-[#8B1538] hover:bg-[#6B0F28] text-white font-medium shadow-sm rounded-xl",
                isMobile ? "h-12 text-base" : "px-6"
              )}
            >
              <Zap className="h-4 w-4 mr-2" />
              Generate Full Mystery
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}
