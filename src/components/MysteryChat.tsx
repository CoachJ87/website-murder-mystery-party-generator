import React, { useState, useRef, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Card, CardHeader, CardContent, CardDescription } from "@/components/ui/card";
import { toast } from "sonner";
import { Send, Loader2, Zap } from "lucide-react";
import { useIsMobile } from "@/hooks/use-mobile";
import ReactMarkdown from 'react-markdown';
import rehypeRaw from 'rehype-raw';
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Separator } from "@/components/ui/separator";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { cn } from "@/lib/utils";
import { useAuth } from "@/context/AuthContext";
import { Message } from "@/components/types";
import { supabase } from "@/lib/supabase";

interface MysteryChatProps {
  initialTheme?: string;
  initialPlayerCount?: number;
  initialHasAccomplice?: boolean;
  initialScriptType?: 'full' | 'pointForm';
  initialAdditionalDetails?: string;
  savedMysteryId?: string;
  onSave: (message: Message) => Promise<void>;
  onGenerateFinal?: (messages: Message[]) => Promise<void>;
  initialMessages?: Message[];
  isLoadingHistory?: boolean;
  systemInstruction?: string;
  preventDuplicateMessages?: boolean;
  skipForm?: boolean;
  needsInitialAIResponse?: boolean;
}

const formSchema = z.object({
  theme: z.string().min(2, {
    message: "Theme must be at least 2 characters.",
  }).max(50, {
    message: "Theme must not be longer than 50 characters.",
  }),
  playerCount: z.number().min(4, {
    message: "Must have at least 4 players"
  }).max(32, {
    message: "Must not have more than 32 players"
  }),
  hasAccomplice: z.boolean().default(false),
  scriptType: z.enum(['full', 'pointForm']).default('full'),
  additionalDetails: z.string().max(500).optional(),
});

export default function MysteryChat({
  initialTheme,
  initialPlayerCount,
  initialHasAccomplice,
  initialScriptType,
  initialAdditionalDetails,
  savedMysteryId,
  onSave,
  onGenerateFinal,
  initialMessages = [],
  isLoadingHistory = false,
  systemInstruction,
  preventDuplicateMessages = false,
  skipForm = false,
  needsInitialAIResponse = false
}: MysteryChatProps) {
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isAiTyping, setIsAiTyping] = useState(false);
  const [currentTheme, setCurrentTheme] = useState(initialTheme || '');
  const [currentPlayerCount, setCurrentPlayerCount] = useState<number | null>(initialPlayerCount || null);
  const [currentHasAccomplice, setCurrentHasAccomplice] = useState(initialHasAccomplice || false);
  const [currentScriptType, setCurrentScriptType] = useState(initialScriptType || 'full');
  const [currentAdditionalDetails, setCurrentAdditionalDetails] = useState(initialAdditionalDetails || '');
  const [hasTriggeredInitialResponse, setHasTriggeredInitialResponse] = useState(false);
  const { isAuthenticated } = useAuth();
  const isMobile = useIsMobile();
  const bottomRef = useRef<HTMLDivElement>(null);

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      theme: initialTheme || "",
      playerCount: initialPlayerCount || 4,
      hasAccomplice: initialHasAccomplice || false,
      additionalDetails: initialAdditionalDetails || "",
    },
    mode: "onChange"
  });

  // Helper function to ensure proper timestamp handling
  const ensureValidTimestamp = (message: any): Message => {
    let timestamp: Date;
    
    if (message.timestamp) {
      timestamp = message.timestamp instanceof Date ? message.timestamp : new Date(message.timestamp);
    } else if (message.created_at) {
      timestamp = new Date(message.created_at);
    } else {
      timestamp = new Date();
    }

    return {
      id: message.id || Date.now().toString(),
      content: message.content || '',
      is_ai: message.is_ai !== undefined ? message.is_ai : (message.role === 'assistant'),
      timestamp: timestamp,
      isAutoGenerated: message.isAutoGenerated || false
    };
  };

  useEffect(() => {
    const processedMessages = initialMessages.map(ensureValidTimestamp);
    setMessages(processedMessages);
  }, [initialMessages]);

  // New effect to handle initial AI response
  useEffect(() => {
    if (needsInitialAIResponse && !hasTriggeredInitialResponse && messages.length > 0 && !isLoadingHistory) {
      console.log("Triggering initial AI response for user message");
      setHasTriggeredInitialResponse(true);
      
      // Find the last user message to respond to
      const lastUserMessage = messages.filter(msg => !msg.is_ai).pop();
      if (lastUserMessage) {
        triggerAIResponse(lastUserMessage.content);
      }
    }
  }, [needsInitialAIResponse, hasTriggeredInitialResponse, messages, isLoadingHistory]);

  // FIXED: Enhanced function to properly detect if we have player count info
  const hasPlayerCountInfo = () => {
    // Don't consider initialPlayerCount as "having info" unless it's explicitly set and not a default
    if (initialPlayerCount && initialPlayerCount >= 4 && initialPlayerCount <= 32 && currentPlayerCount && currentPlayerCount >= 4 && currentPlayerCount <= 32) {
      console.log("Has explicit valid player count from props:", initialPlayerCount);
      return true;
    }
    
    // Check if any message explicitly mentions valid player count
    const hasPlayerCountInMessages = messages.some(msg => {
      const content = msg.content.toLowerCase();
      // Look for explicit player count mentions with numbers in valid range
      const playerCountMatch = content.match(/(\d+)\s*(player|people|guest|character|participant)/i);
      if (playerCountMatch) {
        const count = parseInt(playerCountMatch[1]);
        if (count >= 4 && count <= 32) {
          console.log("Found valid player count in message:", content.substring(0, 100));
          return true;
        }
      }
      return false;
    });
    
    console.log("Has player count in messages:", hasPlayerCountInMessages);
    return hasPlayerCountInMessages;
  };

  // Helper function to detect if we have theme information
  const hasThemeInfo = () => {
    const hasTheme = currentTheme && currentTheme.trim() !== '' && currentTheme !== 'Murder Mystery';
    console.log("Has theme info:", hasTheme, "Theme:", currentTheme);
    return hasTheme;
  };

  // FIXED: More accurate detection of new conversations that need player count question
  const isNewConversation = () => {
    const playerCountInfo = hasPlayerCountInfo();
    const isNew = messages.length <= 1 && !playerCountInfo;
    console.log("Is new conversation check:", {
      messageCount: messages.length,
      hasPlayerCount: playerCountInfo,
      isNew: isNew
    });
    return isNew;
  };

  useEffect(() => {
    if (initialTheme) {
      form.setValue("theme", initialTheme);
      setCurrentTheme(initialTheme);
    }
    if (initialPlayerCount) {
      form.setValue("playerCount", initialPlayerCount);
      setCurrentPlayerCount(initialPlayerCount);
    }
    if (initialHasAccomplice) {
      form.setValue("hasAccomplice", initialHasAccomplice);
      setCurrentHasAccomplice(initialHasAccomplice);
    }
    if (initialScriptType) {
      setCurrentScriptType(initialScriptType);
    }
    if (initialAdditionalDetails) {
      form.setValue("additionalDetails", initialAdditionalDetails);
      setCurrentAdditionalDetails(initialAdditionalDetails);
    }
  }, [initialTheme, initialPlayerCount, initialHasAccomplice, initialScriptType, initialAdditionalDetails, form]);

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, isAiTyping]);

  const createSystemMessage = (data: any) => {
    // For new conversations without player count, return null to let edge function handle the flow
    if (isNewConversation()) {
      console.log("New conversation detected - returning null to let edge function ask for player count");
      return null;
    }

    // Only create detailed system prompt if we have progressed past initial setup
    let systemMsg = "You are a helpful mystery writer. Your job is to help the user create an exciting murder mystery game.";
    
    if (hasThemeInfo()) {
      systemMsg += `\nThe user wants to create a murder mystery with theme: ${currentTheme}. `;
    }
    
    if (hasPlayerCountInfo()) {
      systemMsg += `The user wants to create a murder mystery with ${data.playerCount || currentPlayerCount} players. `;
    }
    
    systemMsg += `The user wants to create a murder mystery with a ${data.scriptType} script. `;
    
    // Add explicit instructions for complete mystery format
    systemMsg += `\n\nImportant: When you have gathered enough information (at minimum theme and player count), provide a complete mystery in this exact format:
    
# "[CREATIVE TITLE]" - A MURDER MYSTERY

## PREMISE
[2-3 paragraphs setting the scene, describing where the murder takes place]

## VICTIM
**[Victim Name]** - [Description of the victim including their role and why they might have enemies]

## CHARACTER LIST (${data.playerCount || currentPlayerCount} PLAYERS)
[List all ${data.playerCount || currentPlayerCount} characters with descriptions]

## MURDER METHOD
[Describe how the murder was committed and what clues might be found]
`;
    
    if (data.additionalDetails) {
      systemMsg += `\nAdditional details: ${data.additionalDetails}. `;
    }
    
    // Disable the question limit in the mystery-ai edge function
    systemMsg += "\n\nNOTE: Do not truncate responses. If asked to generate the full mystery format, always provide the complete structure with all sections.";
    
    return systemMsg;
  };

  // Enhanced AI response function with retry logic
  const callAIWithRetry = async (messages: any[], systemPrompt: string | null, retryCount = 0): Promise<any> => {
    const maxRetries = 3;
    
    try {
      console.log(`Attempt ${retryCount + 1} - Calling mystery-ai function`);
      console.log("Messages being sent:", messages);
      if (systemPrompt) {
        console.log("System prompt:", systemPrompt.substring(0, 200) + "...");
      } else {
        console.log("No custom system prompt - using edge function default");
      }
      
      const requestBody: any = {
        messages: messages,
        promptVersion: 'free',
        preventTruncation: true
      };

      // Only add system prompt if we have one
      if (systemPrompt) {
        requestBody.system = systemPrompt;
      }

      const { data, error } = await supabase.functions.invoke('mystery-ai', {
        body: requestBody
      });

      console.log("Supabase function response:", { data, error });

      if (error) {
        throw new Error(`Supabase function error: ${error.message}`);
      }

      if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
        return data.choices[0].message.content;
      } else if (data && data.error) {
        throw new Error(`API error: ${data.error}`);
      } else {
        throw new Error('Invalid response format from AI service');
      }
    } catch (error) {
      console.error(`Attempt ${retryCount + 1} failed:`, error);
      
      if (retryCount < maxRetries) {
        console.log(`Retrying in ${(retryCount + 1) * 1000}ms...`);
        await new Promise(resolve => setTimeout(resolve, (retryCount + 1) * 1000));
        return callAIWithRetry(messages, systemPrompt, retryCount + 1);
      } else {
        throw error;
      }
    }
  };

  const triggerAIResponse = async (userContent: string) => {
    setIsAiTyping(true);

    try {
      console.log("=== Starting AI Request for Initial Response ===");
      console.log("User message:", userContent);
      console.log("Current conversation length:", messages.length);
      console.log("Has player count info:", hasPlayerCountInfo());
      console.log("Has theme info:", hasThemeInfo());
      console.log("Is new conversation:", isNewConversation());
      
      // FIXED: Improved system prompt logic
      let systemPrompt = null;
      
      // For new conversations without player count, ignore any provided systemInstruction
      // and let the edge function ask for player count
      if (isNewConversation()) {
        console.log("New conversation without player count - no system prompt to let edge function ask for player count");
        systemPrompt = null;
      } else if (hasPlayerCountInfo()) {
        // Only create detailed system prompt if we have player count
        systemPrompt = createSystemMessage({
          theme: currentTheme,
          playerCount: currentPlayerCount,
          hasAccomplice: currentHasAccomplice,
          scriptType: currentScriptType,
          additionalDetails: currentAdditionalDetails
        });
        console.log("Created system prompt because we have player count");
      } else if (systemInstruction) {
        // Use provided system instruction only if it's not a new conversation
        systemPrompt = systemInstruction;
        console.log("Using provided systemInstruction for existing conversation");
      }

      const messagesToSend = messages.map(msg => ({
        role: msg.is_ai ? "assistant" : "user",
        content: msg.content
      }));

      const aiResponse = await callAIWithRetry(messagesToSend, systemPrompt);
      console.log("AI response content:", aiResponse);

      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: aiResponse,
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      const updatedMessages = [...messages, aiMessage];
      setMessages(updatedMessages);

      try {
        await onSave(aiMessage);
      } catch (error) {
        console.error("Error saving AI message:", error);
      }
    } catch (error) {
      console.error('Error calling AI service:', error);
      toast.error("Failed to get AI response. Please try again.");
      
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: "I apologize, but I'm having trouble responding right now. Please try again in a moment.",
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      setMessages([...messages, errorMessage]);
      
      try {
        await onSave(errorMessage);
      } catch (saveError) {
        console.error("Error saving AI error message:", saveError);
      }
    } finally {
      setIsAiTyping(false);
    }
  };

  const handleSendMessage = async (content: string) => {
    if (!content.trim()) return;

    setInput('');

    const userMessage: Message = {
      id: Date.now().toString(),
      content: content.trim(),
      is_ai: false,
      timestamp: new Date(),
      isAutoGenerated: false
    };

    const newMessages = [...messages, userMessage];
    setMessages(newMessages);

    try {
      await onSave(userMessage);
    } catch (error) {
      console.error("Error saving user message:", error);
    }

    setIsAiTyping(true);

    try {
      console.log("=== Starting AI Request ===");
      console.log("User message:", content);
      console.log("Current conversation length:", newMessages.length);
      console.log("Has player count info:", hasPlayerCountInfo());
      console.log("Has theme info:", hasThemeInfo());
      console.log("Is new conversation:", isNewConversation());
      
      // FIXED: Same improved system prompt logic as triggerAIResponse
      let systemPrompt = null;
      
      // For new conversations without player count, ignore any provided systemInstruction
      if (isNewConversation()) {
        console.log("New conversation without player count - no system prompt to let edge function ask for player count");
        systemPrompt = null;
      } else if (hasPlayerCountInfo()) {
        // Only create detailed system prompt if we have player count
        systemPrompt = createSystemMessage({
          theme: currentTheme,
          playerCount: currentPlayerCount,
          hasAccomplice: currentHasAccomplice,
          scriptType: currentScriptType,
          additionalDetails: currentAdditionalDetails
        });
        console.log("Created system prompt because we have player count");
      } else if (systemInstruction) {
        // Use provided system instruction only if it's not a new conversation
        systemPrompt = systemInstruction;
        console.log("Using provided systemInstruction for existing conversation");
      }

      const messagesToSend = newMessages.map(msg => ({
        role: msg.is_ai ? "assistant" : "user",
        content: msg.content
      }));

      const aiResponse = await callAIWithRetry(messagesToSend, systemPrompt);
      console.log("AI response content:", aiResponse);

      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: aiResponse,
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      const updatedMessages = [...newMessages, aiMessage];
      setMessages(updatedMessages);

      try {
        await onSave(aiMessage);
      } catch (error) {
        console.error("Error saving AI message:", error);
      }
    } catch (error) {
      console.error('Error calling AI service:', error);
      toast.error("Failed to get AI response. Please try again.");
      
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: "I apologize, but I'm having trouble responding right now. Please try again in a moment.",
        is_ai: true,
        timestamp: new Date(),
        isAutoGenerated: false
      };

      setMessages([...newMessages, errorMessage]);
      
      try {
        await onSave(errorMessage);
      } catch (saveError) {
        console.error("Error saving AI error message:", saveError);
      }
    } finally {
      setIsAiTyping(false);
    }
  };

  // Styles for markdown content
  const markdownStyles = {
    h1: "text-2xl font-bold mt-4 mb-2",
    h2: "text-xl font-semibold mt-3 mb-2",
    h3: "text-lg font-medium mt-2 mb-1",
    p: "my-1",
    ul: "list-disc pl-6 my-2",
    ol: "list-decimal pl-6 my-2",
    li: "my-1",
    strong: "font-bold",
    em: "italic",
    blockquote: "pl-4 border-l-4 border-gray-300 italic my-2"
  };

  return (
    <div className="flex flex-col h-full space-y-6">
      {!skipForm && (
        <Card className="mb-4">
          <CardHeader>
            <Label className="text-lg">Mystery Settings</Label>
            <CardDescription>
              Configure the basic settings for your murder mystery.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Form {...form}>
              <form className="space-y-4">
                <FormField
                  control={form.control}
                  name="theme"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Theme</FormLabel>
                      <FormControl>
                        <Input
                          placeholder="e.g. Roaring 20s, Space Station"
                          {...field}
                          onChange={(e) => {
                            field.onChange(e);
                            setCurrentTheme(e.target.value);
                          }}
                        />
                      </FormControl>
                      <FormDescription>
                        The overall theme or setting for your mystery.
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="playerCount"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Player Count (4-32)</FormLabel>
                      <FormControl>
                        <Input
                          type="number"
                          placeholder="4"
                          min={4}
                          max={32}
                          {...field}
                          onChange={(e) => {
                            const value = parseInt(e.target.value);
                            if (!isNaN(value)) {
                              field.onChange(value);
                              setCurrentPlayerCount(value);
                            }
                          }}
                        />
                      </FormControl>
                      <FormDescription>
                        The number of players that will be participating in the
                        mystery (between 4 and 32 players).
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="hasAccomplice"
                  render={({ field }) => (
                    <FormItem className="flex flex-row items-center justify-between rounded-lg border p-4">
                      <div className="space-y-0.5">
                        <FormLabel>Accomplice</FormLabel>
                        <FormDescription>
                          Should the murderer have an accomplice?
                        </FormDescription>
                      </div>
                      <FormControl>
                        <Switch
                          checked={field.value}
                          onCheckedChange={(checked) => {
                            field.onChange(checked);
                            setCurrentHasAccomplice(checked);
                          }}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="additionalDetails"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Additional Details</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="Any additional details you want to include?"
                          className="resize-none"
                          {...field}
                          onChange={(e) => {
                            field.onChange(e);
                            setCurrentAdditionalDetails(e.target.value);
                          }}
                        />
                      </FormControl>
                      <FormDescription>
                        Any additional details you want to include?
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </form>
            </Form>
          </CardContent>
        </Card>
      )}

      {/* Chat Container */}
      <div className="border rounded-lg bg-background">
        {/* Chat Messages Area */}
        <div className="h-96 overflow-y-auto p-4 space-y-3">
          {/* Loading History */}
          {isLoadingHistory && (
            <div className="text-center text-muted-foreground">
              <Loader2 className="h-6 w-6 animate-spin mx-auto mb-2" />
              Loading previous messages...
            </div>
          )}
          
          {messages.map((message) => (
            <div
              key={message.id}
              className={cn(
                "flex",
                message.is_ai ? "justify-start" : "justify-end"
              )}
            >
              <div
                className={cn(
                  "max-w-[80%] rounded-lg px-4 py-2",
                  message.is_ai
                    ? "bg-muted border overflow-auto"
                    : "bg-primary text-primary-foreground"
                )}
              >
                {message.is_ai ? (
                  <div className="prose prose-sm dark:prose-invert max-w-none">
                    <ReactMarkdown 
                      rehypePlugins={[rehypeRaw]}
                      components={{
                        h1: ({node, ...props}) => <h1 className="text-2xl font-bold mt-4 mb-2" {...props} />,
                        h2: ({node, ...props}) => <h2 className="text-xl font-semibold mt-3 mb-2" {...props} />,
                        h3: ({node, ...props}) => <h3 className="text-lg font-medium mt-2 mb-1" {...props} />,
                        p: ({node, ...props}) => <p className="my-1" {...props} />,
                        ul: ({node, ...props}) => <ul className="list-disc pl-6 my-2" {...props} />,
                        ol: ({node, ...props}) => <ol className="list-decimal pl-6 my-2" {...props} />,
                        li: ({node, ...props}) => <li className="my-1" {...props} />,
                        strong: ({node, ...props}) => <strong className="font-bold" {...props} />,
                        em: ({node, ...props}) => <em className="italic" {...props} />,
                        blockquote: ({node, ...props}) => <blockquote className="pl-4 border-l-4 border-gray-300 italic my-2" {...props} />
                      }}
                    >
                      {message.content}
                    </ReactMarkdown>
                  </div>
                ) : (
                  <p className="text-sm whitespace-pre-line">{message.content}</p>
                )}
              </div>
            </div>
          )}
          
          {/* AI Typing Indicator */}
          {isAiTyping && (
            <div className="flex justify-start">
              <div className="bg-muted border rounded-lg px-4 py-2 max-w-[80%]">
                <div className="flex space-x-1">
                  <div className="h-2 w-2 bg-muted-foreground rounded-full animate-bounce" style={{ animationDelay: "0ms" }}></div>
                  <div className="h-2 w-2 bg-muted-foreground rounded-full animate-bounce" style={{ animationDelay: "150ms" }}></div>
                  <div className="h-2 w-2 bg-muted-foreground rounded-full animate-bounce" style={{ animationDelay: "300ms" }}></div>
                </div>
              </div>
            </div>
          )}
          <div ref={bottomRef} />
        </div>

        {/* Chat Input Area */}
        <div className="border-t p-4">
          <div className="flex items-center space-x-2">
            <Input
              type="text"
              placeholder="Type your message..."
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                  e.preventDefault();
                  handleSendMessage(input);
                }
              }}
              disabled={isAiTyping}
              className="flex-grow"
            />
            <Button 
              type="submit" 
              onClick={() => handleSendMessage(input)} 
              disabled={isAiTyping}
              size="icon"
            >
              {isAiTyping ? <Loader2 className="h-4 w-4 animate-spin" /> : <Send className="h-4 w-4" />}
            </Button>
          </div>
        </div>
      </div>
      
      {/* Generate Final Mystery Button */}
      {onGenerateFinal && messages.length > 0 && (
        <Button
          onClick={() => onGenerateFinal(messages)}
          className="w-full bg-red-600 hover:bg-red-700"
          size="lg"
        >
          <Zap className="mr-2 h-5 w-5" />
          Generate Final Mystery
        </Button>
      )}
    </div>
  );
}
